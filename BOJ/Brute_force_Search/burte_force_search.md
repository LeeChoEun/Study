# Brute-Force Search 

    - 완전 탐색을 효율적으로 하는 방법을 찾는 것이 포인트

# 날짜 계산 (boj_1476.cpp)
    문제 설명
    E, S, M 존재 (1 <= E <= 15, 1 <= S <= 28, 1 <= M <= 19)
    1년마다 1씩 모두 증가하고 범위를 넘어가면 다시 1로 돌아감
    E S M의 값이 주어졌을 때 값을 만족하는 년도의 최솟값을 출력하는 문제

    문제 풀이 방식 설명
    정답은 15, 28 19의 최소 공배수인 15 * 28 * 19 = 7980 이하 (범위 : 1 ~ 7980)

    년도를 year로 가정하고 1로 초기화
    if문을 사용해 year에서 주어진 e, s, m을 각각 뺀 값을 
    e, s, m 각각 범위의 최댓값을 나누었을 때 모두 0이 된다면
    year 출력
    그렇지 않을 경우 year +1

# 체스판 다시 칠하기 (boj_1018.cpp)
    문제 설명
    N * M 크기의 1*1 검은색과 흰색 정사각형이 무작위로 칠해져 있는 판이 주어짐
    8*8로 잘라서 체스판처럼 만들기 위해 규칙이 맞지 않는 부분은 다시 칠해야 함.
    이 때 다시 칠하는 부분의 최소 개수를 구해 출력하는 문제

    문제 풀이 방식 설명
    체스판은 두가지 종류가 존재:
    왼쪽 상단 사각형을 기준으로 흰색부터 시작하는 체스판(WB), 검은색부터 시작하는 체스판(BW)
    검은색 사각형을 B, 흰색 사각형을 W로 정의하고
    두가지 종류의 체스판을 string형으로 미리 만들어놓기
    * 두가지 종류 중 다시 칠해야하는 가짓수가 적은 체스판을 선택하면 됨

    N, M값과 보드의 모양을 입력 받음
    changeMin이라는 변수 64로 선언(만약 전체 + a를 칠해야한다면 64개가 최소이므로)
    이중 for문(1)을 각각 y, x값으로 선언하고 체스판을 자를 때 왼쪽 가장 상단의 좌표라고 가정함 
    * 따라서 최댓값은 N, M이 아닌 N-8, M-8 (가장 상단의 값이므로)

    그 안에 이중 for문(2)을 선언(i, j)한 뒤, 2개의 체스판과 각각 하나씩 비교해 색이 다르다면 칠해야하는 갯수 +1

    이중 for문(2)가 종료된 후 2개의 체스판 중 어떤 수가 더 작은지 min함수로 비교해 curr_Min변수에 저장
    이후 changeMin(64)와 curr_Min을 한번 더 비교해 최종 result에 저장

    이중 for문(1)이 종료된 후(모든 보드판을 탐색한 후) result 출력


    


