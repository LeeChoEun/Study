# DFS/BFS 알고리즘 정리

    # DFS (Depth-First Search, 깊이 우선 탐색)
        - 한 노드에서 가장 깊숙한 곳까지 탐색하고, 막히면 다시 돌아와서 다른 경로로 탐색하는 방식
        - 재귀 또는 스택을 사용해서 구현함

        특징
        - 한 갈래를 끝까지 탐색한 뒤, 다른 갈래로 이동
        - 순열/조합, 백트래킹에서 자주 사용
        - 재귀 함수로 구현하는 경우가 많음
        - 모든 경로를 탐색할 때 적합

    # BFS (Breadth-First Search, 너비 우선 탐색)
        - 시작 노드에서 가까운 노드붙 한 단계씩 넓게 탐색하며, 모든 인접 노드를 먼저 방문하는 방식
        - 큐를 사용해서 구현함

        특징
        - 가까운 노드부터 탐색
        - 최단 거리 탐색에 적합함
        - 루트에서 레벨 순으로 탐색
        - 큐를 사용항 반복문으로 구현

    # 문제 풀이
        ## 타겟 넘버 (프로그래머스, Level 2)
            문제 설명
            n개의 음이 아닌 정수들과 타겟 넘버가 주어짐
            이 때 n개의 정수에 + or - 부호를 붙여서 타겟 넘버를 만들 수 있는 경우의 수 return

            문제 풀이
            처음에 numbers vector(n개의 음이 아닌 정수가 담긴)와 target(타겟 넘버)가 주어짐

            index, sum, answer을 각각 0으로 초기화해서 선언
            만약 index와 numbers의 size가 같고, sum과 target이 같다면 answer에 경우의 수 ++1하기
            각 정수에 +를 붙였을 때와 -를 붙였을 때 모두 탐색하기 위해 DFS 방식으로 진행
            index를 하나씩 더해가며 sum에 number[index]를 더했을 때, 뺐을 때의 함수를 하나씩 선언해 모든 경우의 수 확인
    
        ## 네트워크 (프로그래머스, Level 3)
            문제 설명
            n개의 컴퓨터가 주어지고 어떤 컴퓨터와 각각 연결되어 있는지에 대한 연결 여부가 같이 주어짐.
            이 때 네트워크의 개수 return
            예를 들어, A, B, C 컴퓨터가 주어지고 A와 B가 연결되어 있고 B와 C가 연결되어 있을 때, A와 C도 간접적으로 연결되어 있는 것으로 간주해 네트워크의 개수는 1개이다.

            문제 풀이
            처음에 n(컴퓨터의 개수)와 2차원 벡터 computers(각 컴퓨터의 연결 상황 1 = 연결 o, 0 = 연결 x)가 주어짐
            answer를 0으로 초기화해 선언,bool형 visited변수를 컴퓨터의 개수만큼 선언해 컴퓨터 방문 여부 저장(false로 초기화)

            n개만큼 for문을 돌며 visited가 false일 때(방문한 적 없을 때) 해당 컴퓨터의 visited를 true로 변경하고, computers의 size만큼 for문을 돌며 같은 컴퓨터가 아니고, 연결이 되어 있으며, 방문한 적이 없는 컴퓨터를 방문한다.

            1개의 컴퓨터가 1번 모든 연결 여부를 완료할 때 마다 answer에 1을 증가시킨다.

        ## 게임 맵 최단거리 (프로그래머스, Level 3)
            문제 설명
            2팀으로 나누어져 게임을 진행하며, n*m의 막혀있거나(0), 뚫려있는 길(1)이 주어진다.
            우리팀은 1행 1열에 위치하고, 상대팀은 n행 m열에 자리한다.
            게임을 시작해서 동서남북 방향으로 한칸씩 움직일 수 있을 때 상대팀 진영에 도착할 수 있는 최단경로의 길이를 return
            도달할 수 없을 때에는 -1 return

            문제 풀이
            최단 경로를 구하는 문제이므로 BFS 사용

            2차원 vector maps(n * m 게임판의 정보)가 주어짐
            전역 변수로 행을 이동할 수 있는 dx[4] = {-1, 1, 0, 0}와 열을 이동할 수 있는 dy[4] = {0, 0, -1, 1}을 선언
            maps의 행과 열 길이를 각각 n, m으로 선언
            각 좌표를 방문했는지 확인하며 거리를 저장하기 위한 n*m 0으로 초기화된 n*m int형 visited 벡터 선언
            BFS를 위한 pair형 queue q선언 (x, y저장)
            
            q에 0,0(시작점) push, visited[0][0] 방문 처리(1)

            !q.empty()가 조건인 while문 선언
            int형 x, y 선언(x = q.front().first, y = q.front().second)
            q.pop()으로 꺼내기
            
            만약 x와 y가 도착지점에 도착하면 거리(visited[x][y]) return

            4방향으로 이동
            - 범위 체크(n*m안에 있는지)
            - 길이가 존재하고, 아직 방문하지 않은 곳이라면
            -> 방문해서 길이 +1하기

            도착할 수 없는 경우에는 -1 return


